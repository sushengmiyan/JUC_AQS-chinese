虽然同步器框架除了互斥锁之外还支持许多其他类型的同步，但是锁的性能是最容易测量和比较的。<br>
即便如此，还是有许多不同的测量方法。这里的实验旨在揭示开销和吞吐量。<br>
在每个测试中，每个线程都重复地更新使用函数计算的伪随机数：<br>
```
nextRandom(int seed):
int t = (seed % 127773) * 16807 –
(seed / 127773) * 2836;
return (t > 0)? t : t + 0x7fffffff;
```
在每个迭代中，一个线程以概率S更新互斥锁下的共享生成器，否则它将在没有锁的情况下更新自己的本地生成器。<br>
这将导致短时间的锁定区域，当线程在持有锁时被抢占时，会将无关的影响降到最低。<br>
函数的随机性有两个目的:它用于决定是否锁定(对于当前的目的，它是一个足够好的生成器)，还使得循环内的代码不可能被简单地优化掉。<br>
比较了四种锁:内置锁、同步锁;互斥量，使用一个简单的互斥量类，如第4节所示;可重入,使用ReentrantLock;并且公平，使用在其“公平”模式中设置的ReentrantLock。<br>
所有测试都使用Sun J2SE1.5 JDK在“server"模式下的build 46(与beta2大致相同)。测试程序在收集测量值之前执行20次非竞争运行，以消除热身效果。<br>
每个线程运行1000万个迭代的测试，除了公平模式测试只运行100万个迭代。
在4台基于x86的机器和4台基于UltraSparc的机器上进行了测试。所有x86机器都使用基于RedHat nptl的2.4内核和库运行Linux。<br>
所有超parc机器都在运行Solaris-9。在测试时，所有系统的负载都很轻。测试的性质并不要求它们完全空闲。<br>
“4P”名称反映了一个事实，即双超线程(HT) Xeon的行为更像一个4路而不是2路机器。这里没有试图使分歧正常化。<br>
如下所示，同步的相对成本与处理器的数量、类型或速度没有简单的关系。<br>


