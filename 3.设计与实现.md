3.设计与实现
====

同步器背后的基本思想非常简单。一个acquire操作如下：
```
while (同步状态不允许acquire) {
    当前线程如果不在队列中就增加到队列;
    可能阻塞当前队列;
}
当前线程如果在队列中就出列;
```
一个release操作如下：
```
更新同步状态;
if (状态允许阻塞线程acquire)
解锁一个或多个队列中的线程; 
```
对这些行动的支持需要协调三个基本组成部分:
同步状态的原子性管理；<br>
阻塞和解除阻塞线程；<br>
保持队列；<br>
也许可以创建一个框架，允许这三个部分中的每一个独立变化。<br>
然而，这既不是很有效也不是很有用。例如，队列节点中保存的信息必须与解除阻塞所需的信息相匹配，导出方法的签名取决于同步状态的特性。<br>
同步器框架的核心设计决策是选择这三个组件的每个具体实现，同时仍然允许在如何使用它们时使用多种选项。<br>
这有意地限制了适用性的范围，但是提供了足够有效的支持，在实际应用框架的情况下，几乎没有理由不使用框架(而是从头构建同步器)。<br>

3.1 同步状态
--

AbstractQueuedSynchronizer类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个状态。<br>
这些方法又依赖于java.util.concurrent. atomic的支持，这个包在读写上提供JSR133 (Java内存模型)兼容的volatile语义，并且通过使用本地的compare-and-swap或load-linked/store-conditional指令来实现compareAndSetState，只有当状态具有给定的期望值时，才原子地将状态设置为给定的新值。<br>
将同步状态限制为32位int是一个实用的决定。虽然JSR166还提供了64位长字段上的原子操作，但是必须在足够多的平台上使用内部锁来模拟这些操作，从而导致同步器不能很好地执行。<br>
在将来，很可能会出现第二个专门用于64位状态(即，使用long控制参数)的基类将被添加。<br>
然而，现在没有一个令人信服的理由把它包括在这个包中。目前，32位对大多数应用程序来说已经足够了。<br>
只有一个java.util.concurrent并发同步器类CyclicBarrier需要更多的位来维护状态，因此它使用锁(与包中大多数高级实用程序一样)。<br>
基于AbstractQueuedSynchronizer的具体类必须根据这些导出的状态定义tryacquisition和tryRelease方法，以便控制获取acquire和释放release操作。<br>
如果获得了同步，tryacquisition方法必须返回true;如果新的同步状态允许将来获得，tryRelease方法必须返回true。这些方法接受一个int参数，该参数可用于通信所需的状态。例如，在重入锁中，要在从条件wait返回后重新获取锁时重新建立递归计数。许多同步器不需要这样的参数，所以忽略它。

3.2 阻塞
--

在JSR166之前，还没有可用的Java API来阻塞和取消阻塞线程，以便创建不基于内置监视器的同步器。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用。如果一个未阻塞的线程在阻塞线程执行挂起(suspend)之前调用恢复(resume)，那么resume操作将不起作用。
java.util.concurrent.locks 包包含了LockSupport类,类中有方法针对这个问题进行处理。<br>
LockSupport.park方法阻塞当前线程，直到或者除非LockSupport.unpark这个方法被处理。（虚拟唤醒也是被支持的）。<br>
对unpark的调用不被“计数”，因此在一个park前多个unpark只会取消对一个park的阻塞。此外，这适用于per-thread，而不是per-synchronizer。<br>
调用新同步器上的park的线程可能会立即返回，因为在以前的使用中有一个“剩余的”unpark。然而，在没有unpark的情况下，它的下一个调用将被阻塞。<br>
虽然可以显式地清除这种状态，但是不值得这样做。当需要多次调用park时，调用它会更有效。<br>
这个简单的机制在某种程度上类似于solars -9线程库[11]、WIN32“消耗性事件”和Linux NPTL线程库中使用的机制，因此可以有效地映射到Java运行的最常见平台上的每一个线程库。<br>
（不过，为了适应现有的运行时设计，Solaris和Linux上当前的Sun Hotspot JVM参考实现实际上使用了pthread condvar。)。<br>
park方法还支持可选的相对和绝对超时，并与JVM线程.interrupt支持集成——中断一个线程将其unparks。

3.3 队列
--

框架的核心是维护阻塞线程的队列，这里将其限制为FIFO队列。因此，该框架不支持基于优先级的同步。<br>
目前，几乎没有争议的是，同步队列的最合适选择是非阻塞数据结构，这些数据结构本身不需要使用低级锁来构造。<br>
其中，有两个主要的候选:Mellor-Crummey和Scott (MCS)锁[9]的变体，以及Craig, Landin和Hagersten (CLH)锁[5][8][10]的变体。<br>
历史上，CLH锁只在自旋锁中使用。但是，在同步器框架中，它们看起来比MCS更易于使用，因为它们更容易适应处理取消和超时，所以选择了MCS作为基础。<br>
最终的设计与原来的CLH结构需要解释的相差甚远。<br>
CLH队列不是很像队列，因为它的入队列和出队列操作与它作为锁的使用密切相关。<br>
它是一个链接队列，通过两个原子可更新字段head和tail访问，它们最初都指向一个虚拟节点。

