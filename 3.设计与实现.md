3.设计与实现
====

同步器背后的基本思想非常简单。一个acquire操作如下：
```
while (同步状态不允许acquire) {
    当前线程如果不在队列中就增加到队列;
    可能阻塞当前队列;
}
当前线程如果在队列中就出列;
```
一个release操作如下：
```
更新同步状态;
if (状态允许阻塞线程acquire)
解锁一个或多个队列中的线程; 
```
对这些行动的支持需要协调三个基本组成部分:
同步状态的原子性管理；<br>
阻塞和解除阻塞线程；<br>
保持队列；<br>
也许可以创建一个框架，允许这三个部分中的每一个独立变化。<br>
然而，这既不是很有效也不是很有用。例如，队列节点中保存的信息必须与解除阻塞所需的信息相匹配，导出方法的签名取决于同步状态的特性。<br>
同步器框架的核心设计决策是选择这三个组件的每个具体实现，同时仍然允许在如何使用它们时使用多种选项。<br>
这有意地限制了适用性的范围，但是提供了足够有效的支持，在实际应用框架的情况下，几乎没有理由不使用框架(而是从头构建同步器)。<br>

3.1 同步状态
--

AbstractQueuedSynchronizer类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个状态。<br>
这些方法又依赖于java.util.concurrent. atomic的支持，这个包在读写上提供JSR133 (Java内存模型)兼容的volatile语义，并且通过使用本地的compare-and-swap或load-linked/store-conditional指令来实现compareAndSetState，只有当状态具有给定的期望值时，才原子地将状态设置为给定的新值。<br>
将同步状态限制为32位int是一个实用的决定。虽然JSR166还提供了64位长字段上的原子操作，但是必须在足够多的平台上使用内部锁来模拟这些操作，从而导致同步器不能很好地执行。<br>
在将来，很可能会出现第二个专门用于64位状态(即，使用long控制参数)的基类将被添加。<br>
然而，现在没有一个令人信服的理由把它包括在这个包中。目前，32位对大多数应用程序来说已经足够了。<br>
只有一个java.util.concurrent并发同步器类CyclicBarrier需要更多的位来维护状态，因此它使用锁(与包中大多数高级实用程序一样)。<br>
基于AbstractQueuedSynchronizer的具体类必须根据这些导出的状态定义tryacquisition和tryRelease方法，以便控制获取acquire和释放release操作。<br>
如果获得了同步，tryacquisition方法必须返回true;如果新的同步状态允许将来获得，tryRelease方法必须返回true。这些方法接受一个int参数，该参数可用于通信所需的状态。例如，在重入锁中，要在从条件wait返回后重新获取锁时重新建立递归计数。许多同步器不需要这样的参数，所以忽略它。

3.2 阻塞
--

在JSR166之前，还没有可用的Java API来阻塞和取消阻塞线程，以便创建不基于内置监视器的同步器。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用。如果一个未阻塞的线程在阻塞线程执行挂起(suspend)之前调用恢复(resume)，那么resume操作将不起作用。
java.util.concurrent.locks 包包含了LockSupport类,类中有方法针对这个问题进行处理。<br>
LockSupport.park方法阻塞当前线程，直到或者除非LockSupport.unpark这个方法被处理。（虚拟唤醒也是被支持的）。<br>
对unpark的调用不被“计数”，因此在一个park前多个unpark只会取消对一个park的阻塞。此外，这适用于per-thread，而不是per-synchronizer。<br>
调用新同步器上的park的线程可能会立即返回，因为在以前的使用中有一个“剩余的”unpark。然而，在没有unpark的情况下，它的下一个调用将被阻塞。<br>
虽然可以显式地清除这种状态，但是不值得这样做。当需要多次调用park时，调用它会更有效。<br>
这个简单的机制在某种程度上类似于solars -9线程库[11]、WIN32“消耗性事件”和Linux NPTL线程库中使用的机制，因此可以有效地映射到Java运行的最常见平台上的每一个线程库。<br>
（不过，为了适应现有的运行时设计，Solaris和Linux上当前的Sun Hotspot JVM参考实现实际上使用了pthread condvar。)。<br>
park方法还支持可选的相对和绝对超时，并与JVM线程.interrupt支持集成——中断一个线程将其unparks。

3.3 队列
--

框架的核心是维护阻塞线程的队列，这里将其限制为FIFO队列。因此，该框架不支持基于优先级的同步。<br>
目前，几乎没有争议的是，同步队列的最合适选择是非阻塞数据结构，这些数据结构本身不需要使用低级锁来构造。<br>
其中，有两个主要的候选:Mellor-Crummey和Scott (MCS)锁[9]的变体，以及Craig, Landin和Hagersten (CLH)锁[5][8][10]的变体。<br>
历史上，CLH锁只在自旋锁中使用。但是，在同步器框架中，它们看起来比MCS更易于使用，因为它们更容易适应处理取消和超时，所以选择了MCS作为基础。<br>
最终的设计与原来的CLH结构需要解释的相差甚远。<br>
CLH队列不是很像队列，因为它的入队列和出队列操作与它作为锁的使用密切相关。<br>
它是一个链接队列，通过两个原子可更新字段head和tail访问，它们最初都指向一个虚拟节点。<br>
 ![image](https://github.com/sushengmiyan/JUC_start/blob/master/images/001.jpg)<br>
新节点node使用原子操作进入队列:
```
do { pred = tail;
} while(!tail.compareAndSet(pred, node));
```
每个节点的发布状态都保存在其前身节点中。所以，自旋锁的“自旋”看起来是这样的:<br>
```
while (pred.status != RELEASED) ; // spin
```
旋转之后的dequeue操作只需要设置head字段指向刚刚获得锁的节点:
```
head = node; 
```
CLH锁的优点之一是排队和退出队列速度快、无锁、无阻塞(即使在争用的情况下，一个线程也总是会赢得插入竞争，所以会取得进展)。<br>
检测是否有线程正在等待也是快速的(只要检查头部是否与尾部相同);而且发布状态是分散的，避免了一些内存争用。<br>
在CLH锁的最初版本中，甚至没有连接节点的链接。在自旋锁中，pred变量可以作为局部变量保存。<br>
然而，Scott和Scherer[10]表明，通过显式地维护节点中的前置字段，CLH锁可以处理超时和其他形式的取消:如果节点的前置取消了，则节点可以向上滑到使用前一个节点的状态字段。<br>

使用CLH队列来阻塞同步器所需的主要额外修改是为一个节点提供一种有效的方法来定位其后续节点。<br>
在自旋锁中，节点只需要更改其状态，它的后续节点将在下一次自旋时注意到这一点，因此链接是不必要的。<br>
但是在阻塞同步器中，节点需要显式地唤醒(unpark)它的后续。AbstractQueuedSynchronizer队列节点包含到其后续节点的下一个链接。<br>
但是，由于没有使用compareAndSet实现双链表节点的无锁原子插入的实用技术，所以这个链接不是原子插入的一部分;它只是简单地在插入后赋值。<br>
pred.next = node; 这反映在所有的用法中。next链接只作为优化路径处理。<br>
如果节点的后继节点似乎不存在(或似乎被取消)，则始终可以从列表的末尾开始，然后使用pred字段向后遍历，以准确地检查是否真的存在。<br>

第二组修改是使用每个节点中保存的status字段来控制阻塞，而不是旋转。<br>
在同步器框架中，排队的线程只有通过在具体子类中定义的tryacquisition方法才能从获取操作返回；一个单独的“released”位是不够的。<br>
但是仍然需要控制，以确保活动线程只允许在位于队列头部时调用tryacquisition。在这种情况下，它可能无法获得和(重新)阻塞。<br>
这不需要每个节点的状态标志，因为可以通过检查当前节点的前身是否为head来确定权限。<br>
与自旋锁的情况不同，没有足够的内存争用读取头来保证复制。但是，取消状态必须仍然存在于状态字段中。<br>

队列节点状态字段还用于避免不必要的调用park和unpark。<br>
虽然这些方法作为阻塞原语相对较快，但是在Java和JVM运行时以及/或OS之间的边界交叉时，它们会遇到可避免的开销。<br>
调用park之前，线程设置signal me位，并且调用park之前再次检查同步和节点状态。释放线程会清除状态。<br>
这将避免线程不必要地频繁尝试阻塞，特别是对于锁类，在锁类中，等待下一个符合条件的线程获得锁所花费的时间会加重其他争用效果。<br>
这也避免了需要释放线程来确定它的后继线程，除非后继线程已经设置了信号位。<br>
这反过来又消除了必须遍历多个节点才能处理明显为空的next字段的情况，除非在取消的同时发出信号。<br>
同步器框架中使用的CLH锁的变体与其他语言中使用的CLH锁的主要区别可能在于，依赖垃圾收集来管理节点的存储回收，从而避免了复杂性和开销。<br>
然而，依赖GC仍然会导致链接字段为空，而这些字段肯定永远不需要。这通常可以在退出队列时完成。<br>
否则，未使用的节点仍然是可访问的，导致它们不可收集。<br>
J2SE1.5版本的源代码文档中描述了一些更小的调优，包括CLH队列在第一次争用时所需的初始虚拟节点的延迟初始化。<br>

略去这些细节，基本获取操作(排他的、不可中断的、不定时的)的最终实现的一般形式是:
```
if (!tryAcquire(arg)) {
node = create and enqueue new node;
pred = node's effective predecessor;
while (pred is not head node || !tryAcquire(arg)) {
if (pred's signal bit is set)
park();
else
compareAndSet pred's signal bit to true;
pred = node's effective predecessor;
}
head = node;
}
```
释放操作是：
```
if (tryRelease(arg) && head node's signal bit is set) {
compareAndSet head's signal bit to false;
unpark head's successor, if one exists
}
```
当然，主获取循环的迭代次数取决于tryacquisition的性质。<br>
否则，在没有取消的情况下，获取和释放的每个组件都是一个固定时间的O(1)操作，跨线程平摊。不管park在任何操作系统线程调度发生。<br>
取消支持主要是在获取循环中每次从park返回时检查中断或超时。<br>
由于超时或中断而被取消的线程将设置其节点状态并卸载其后续线程，以便重新设置链接。<br>
取消时，确定前代和后代以及重置状态可能包括O(n)遍历(其中n是队列的长度)。因为线程再也不会阻塞已取消的操作，所以链接和状态字段趋向于快速恢复。<br>

3.4条件队列
--

同步器框架提供了一个条件对象类，供同步器使用，同步器维护和符合独占同步锁接口。<br>
可以将任意数量的条件对象附加到锁对象上，提供经典的监视器风格的等待、信号和信号所有操作，包括超时操作，以及一些检查和监视方法。<br>
通过修复一些设计决策，条件对象类使条件能够有效地与其他同步操作集成。<br>
该类只支持java风格的monitor访问规则，其中只有当拥有条件的锁由当前线程持有时，条件操作才是合法的(有关替代方法的讨论，请参阅[4])。<br>
因此，附加到ReentrantLock的条件对象的行为与内置监视器(通过对象等等)的行为相同)，只在方法名、额外功能以及每个锁可以声明多个条件等方面有所不同。<br>
条件对象使用与同步器相同的内部队列节点，但在单独的条件队列中维护它们。<br>
信号操作实现为从条件队列到锁队列的队列传输，而不必在发出信号的线程重新获得锁之前唤醒它。<br>
基本的await操作如下：
```
create and add new node to condition queue;
release lock;
block until node is on lock queue;
re-acquire lock;
```
signal操作如下：
```
transfer the first node from condition queue to lock queue;
```
因为这些操作只在持有锁时执行，所以它们可以使用顺序链接的队列操作(在节点中使用nextWaiter字段)来维护条件队列。<br>
传输操作只是从条件队列断开第一个节点的链接，然后使用CLH插入将其附加到锁队列。<br>

实现这些操作的主要复杂性是处理由于超时或Thread.interrupt而取消条件等待。<br>
约在同一时间发生的取消和信号遇到比赛，其结果符合内置监视器的规范。正如JSR133中修改过的，这些规则要求，如果中断发生在信号之前，那么wait方法必须在重新获取锁之后抛出InterruptedException。<br>
但是如果它在一个信号之后被中断，那么这个方法必须返回而不抛出异常，但是要设置它的线程中断状态。<br>
为了保持适当的顺序，队列节点状态中的一个位记录节点是否已经(或正在)被传输。<br>
信令代码和取消代码都试图比较和设置此状态。如果一个信号操作丢失了这个竞争，那么它将传输队列上的下一个节点(如果存在下一个节点)。<br>
如果取消操作失败，则必须中止传输，然后等待锁的重新获取。后一种情况引入了潜在的无界自旋。<br>
被取消的等待在节点成功插入锁队列之前不能开始锁的重新获取，因此必须旋转等待信号线程执行CLH队列插入compareAndSet才能成功。<br>
这里很少需要旋转，需要使用线程。提供调度提示，指示其他线程(理想情况下是执行信号的线程)应该运行。<br>
虽然可以在这里实现帮助取消插入节点的策略，但是这种情况非常罕见，无法证明这将带来额外的开销。<br>
在所有其他情况下，这里和其他地方的基本机制都不使用自旋或yield，这在单处理器上保持了合理的性能。<br>







 
