2.需求
====


2.1 功能需求
--
同步器一般包含两种方法[7]，一种是acquire，另一种是release。acquire操作阻塞调用的线程，直到或除非同步状态允许其继续执行。<br>
而release操作则是通过某种方式改变同步状态，使得一个或多个被acquire阻塞的线程继续执行。<br>
java.util.concurrent包并没有给同步器的API做一个统一的定义。有些是通过公共接口(例如锁)定义的，但是其他的只包含特定的版本。<br>
因此在不同的类中，acquire和release操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get，在这个框架里，这些方法都是acquire操作。但是，为支持一系列通用的使用选项，在类间都有个一致约定。当有意义时，每个同步器都支持：非阻塞同步尝试(例如，tryLock)以及阻塞同步尝试;可选的超时设置，因此应用程序可以选择放弃等待。
通过中断的可取消性，通常分为一个可取消的获取版本和一个不可取消的获取版本。<br>
同步器可能会根据它们是否只管理独占状态(即一次只有一个线程在可能的阻塞点之后继续运行)和共享状态(至少有多个线程可以同时继续运行)而有所不同。<br>
常规锁类当然只维护独占状态，但是计数信号量可以由计数允许的尽可能多的线程获得。要广泛使用，框架必须支持这两种操作模式。<br>
java.util.concurrent包也定义了Condition接口，支持监视器风格的等待/信号操作，这些操作可能与独占锁类Lock相关联，并且其实现本质上与其关联的锁类Lock交织在一起。

2.2 性能目标
--

Java内置锁(使用synchronized的方法或代码块是一直以来都在被人们关注的性能问题，并且已经有一系列的文章描述其构造（例如引文[1],[3]）。<br>
然而，这类工作的主要焦点是最小化空间开销(因为任何Java对象都可以用作锁)，以及在单处理器上的单线程上下文中最小化时间开销。<br>
这些都不是某个特别重要的问题:程序员只在需要的时候才会构建同步器,因此不需要压缩空间,并且同步器几乎是专门用在多线程设计中(越来越频繁地在多处理器),这种情况下，偶尔争用是在预料之中的。<br>
因此，常规的JVM优化锁策略主要针对零争用情况，而将其他情况留给不那么可预测的“慢路径”[12]，对于严重依赖java.util.concurrent的典型多线程服务器应用程序来说，常规的策略并不适用。<br>
相反，这里的主要性能目标是可伸缩性:即使在争用同步器时，也可预测地保持效率，尤其是在争用同步器时。理想情况下，无论有多少线程尝试通过同步点，通过同步点所需的开销都应该是常量。<br>
在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。但是，这必须与资源考虑因素相平衡，包括总CPU时间需求、内存流量和线程调度开销。<br>
例如，自旋锁通常比阻塞锁提供更短的获取时间，但通常会浪费周期并产生内存争用，因此通常不常用。<br>
这些目标包含两种一般的使用风格。大多数应用程序应该最大限度地提高总吞吐量，最多也只能容忍对减少饥饿的概率保证。<br>
然而，在资源控制等应用程序中，维护线程间访问的公平性要重要得多，这可以容忍较差的聚合吞吐量。<br>
没有一个框架能够代表用户在这些冲突的目标之间做出决定;相反，必须适应不同的公平政策。<br>
不管同步器的内部设计有多好，它们都是同步器，将在某些应用程序中产生性能瓶颈。<br>
因此，框架必须能够监视和检查基本操作，以允许用户发现和缓解瓶颈。<br>
这至少(也是最有用的)需要提供一种方法来确定有多少线程被阻塞。
